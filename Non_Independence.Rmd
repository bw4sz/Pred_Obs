---
title: "Structural independence in the logistic model"
author: "Ben Weinstein"
date: "Thursday, February 12, 2015"
output: html_document
---

```{r,message=FALSE,warning=FALSE}
library(knitr)
library(pez)
library(ape)
library(dplyr)
library(ggplot2)
library(reshape2)
library(vegan)
library(RColorBrewer)
library(gridExtra)
library(scales)
library(stringr)
library(picante)
library(foreach)
library(doSNOW)

opts_chunk$set(warning=FALSE,message=FALSE,echo=TRUE)
opts_chunk$set(cache=TRUE, cache.path = 'Independence_cache/', fig.path='figure/',fig.width=11,fig.height=6)

load("Independence.Rdata")

```

#Problem Statement

```
Suppose there are three species, 1, 2, and 3, with the distance between 1 and 2 = 1, and between 3 and the other two species = 2. Then assume three sites with each site having two species, with species 1, 2,  and 3 missing from sites 1, 2, and 3, respectively. So the data look like:
```

```{r}
dat <- data.frame(sp=c(1,2,3,1,2,3,1,2,3), site=c(1,1,1,2,2,2,3,3,3), Y=c(0,1,1,1,0,1,1,1,0), x=c(1,2,2,2,1,2,1,1,2))
```

```{r}
ggplot(dat,aes(x=x,y=Y)) + geom_point() + geom_smooth(method="lm")
glm(formula = Y ~ x, family = "binomial", data = dat)
```

So this gives a positive relationship between distance and  presence, even though the presence of species is random under the constraint that there are two species in each site. Obviously, this isn’t a desirable property. 

The reason that you get this is that the values of Y and x are structurally intertwined, so the values of Y aren’t independent.

I’m wondering if there is a simpler way to do this


----

----

----

#Aim
To address Tony's concern, i want to evaluate: 

* How this potential non-independence could effect results

* What is the range of covariates we could expect by random chance

```{r,echo=FALSE}
#Define co-occur function

co_occur<-function(dat,trx,ctrx){
 
f<-split(dat,dat$site)

#remove the localities with only 2 species
f<-f[sapply(f,function(x) sum(x$Y)) > 1]

if(length(f)==0){return(NA)}

#Get closest related species in each site
closest<-lapply(f,function(x){
  
  #species present
  pres<-x$sp[x$Y==1]
    dis<-ctrx[rownames(ctrx) %in% trx$tip.label,colnames(ctrx) %in% pres]
    apply(dis,1,function(y){
      as.matrix(min(y[!y==0]))
      })
  }) 

#melt each list, a bit ugly
tomerge<-lapply(closest,function(x){
 dm<-melt(as.matrix(x))[,-2]
 colnames(dm)<-c("sp","x")
 return(dm)})

tomerge<-melt(tomerge,id.var=c("sp"))

tomerge<-dcast(tomerge,...~variable)
colnames(tomerge)<-c("sp","site","x")

#need to be characters not factors
dat$site<-as.character(dat$site)
tomerge$site<-as.character(tomerge$site)

PA_phylo<-merge(dat,tomerge,by=c("site","sp"))
PA_phylo$Y<-as.numeric(PA_phylo$Y)

#remove Inf lengths, no co-occurrence
PA_phylo[!is.finite(PA_phylo$Y),"Y"]<-NA

return(PA_phylo)
}

```

##What does the relationship look like with increasing species and sites

Let's generalize this structure and see how this relationship changes with more sites and species, does it flatten out?

  * Each species draw is bernoulli trial
  * There is no min or max richness

###Simulate phylogeny
  * Start with a balanced tree, we can check other topologies as well

### Build a function to compute logistic regression for any given number of species in a phylogeny and sites

  * Occupancy is drawn from a bernoulli trial 
  
```{r}

simL<-function(species,sites){

#Simulate a balanced phylogeny
trx<-compute.brlen(stree(species,"balanced",tip.label=1:species))

#Cophenetic matrix
ctrx<-cophenetic(trx)

#Create data.frame
sp=rep(1:species,sites)
site=as.vector(sapply(1:sites,function(x) rep(x,species)))
dat<-data.frame(sp,site)

#Presence/absence
dat$Y<-rbinom(sites*species,1,.5)

#Compute co-occurrence
dat<-co_occur(dat,trx,ctrx)
return(dat)}
```

## Iterate over a large parameter space

```{r}
species.space<-rep(2^(3:7))
site.space<-rep(c(20,40,60,80,100),500)
```

#Simulate Data

  * For each site and species combination draw random occurrence
  
```{r}
simdat<-lapply(species.space,function(x){ 
    lapply(site.space,function(y){
      l<-simL(x,y)  
  mod<-glm(data=l,formula = Y ~ x, family = "binomial") 
  mode<-summary(mod)$coefficients[,"Estimate"]
  data.frame(Intercept=mode[[1]],x=mode[[2]])
      })
})
  
#name layers
names(simdat)<-species.space

for(x in 1:length(simdat)){
  names(simdat[[x]])<-site.space
}

```

## View regression
```{r}
mdat<-melt(simdat)
colnames(mdat)<-c("variable","Estimate","Sites","Species")

mdat$Sites<-as.numeric(mdat$Sites)
mdat$Species<-as.numeric(mdat$Species)

ggplot(mdat,aes(x=as.factor(Species),y=Estimate,fill=as.factor(Sites))) + geom_violin() + theme_bw() + labs(fill="# of Sites",x="# of Species", y= "Covariate Estimate for phylogenetic distance to closest related species") + coord_flip() + facet_wrap(~Sites,ncol=5) + ggtitle("Null Distribution: Sensitivity Analysis")
```

### Conclusion

The relationship between x and y is structure, since a species occurring at a site changes the phylogenetic composition at the site. However, this relationship is largely the same across number of sites and number of species. This suggestions its the topology of the tree that controls the null distribution of potential covariates.

The way forward is then to randomize the tips of the phylogeny by creating random assemblages of the same size and species prevalence and compare the observed glm estimate  with the null distribution of covariate estimates and consider how probability of observing our estimate given the topology of our tree.

##Observed versus null distribution

Read in data
```{r}
#read in tree
trx<-read.tree("InputData\\hum294.tre")

new<-str_extract(trx$tip.label,"(\\w+).(\\w+)")
#get duplicates
trx<-drop.tip(trx,trx$tip.label[duplicated(new)])

#name tips.
trx$tip.label<-str_extract(trx$tip.label,"(\\w+).(\\w+)")

ctrx<-cophenetic(trx)

#standardize the distances, just to avoid rounding error.
ctrx<-ctrx/max(ctrx)



siteXspp<-read.csv("C:/Users/Ben/Dropbox/Thesis/Pred_Realized/Assemblages/SiteXsppraster.csv",row.names=1)

dim(siteXspp)
print("133 Species at 201 Sites")
source("SpeciesOverlapSourceFunctions.R")

```

```{r}
#definite function to randomize assemblage and compute glm
randomCo<-function(){
  r<-randomizeMatrix(siteXspp,"independentswap")
  l<-co_occur(melt(r))
  mod<-glm(data=l,formula = P_A ~ poly(Phylo.Relatedness,2), family = "binomial") 
  mode<-summary(mod)$coefficients[,"Estimate"]
  data.frame(Intercept=mode[[1]],x=mode[[2]],x2=mode[[3]])
}
```

```{r}
cl<-makeCluster(20,"SOCK")
registerDoSNOW(cl)
out<-foreach(x=1:1000,.packages=c("picante","reshape2")) %dopar% {
  randomCo()
  }

stopCluster(cl)
```

#Observed value
```{r}
l<-co_occur(melt(as.matrix(siteXspp)))
  mod<-glm(data=l,formula = P_A ~ poly(Phylo.Relatedness,2), family = "binomial") 
  mode<-summary(mod)$coefficients[,"Estimate"]
  observed<-melt(data.frame(Intercept=mode[[1]],x=mode[[2]],x2=mode[[3]]))
```

#Visualize null distribution versus observed value

```{r,eval=TRUE}

#melt data frame
dat<-melt(out)

ggplot(dat,aes(x=value)) + geom_histogram() + facet_wrap(~variable,scales="free") + theme_bw() + ggtitle("Null Distribution of GLM Covariates") + geom_vline(data=observed,aes(xintercept=value),col='red',linetype='dashed')

```

The red dashed line is the observed glm estimate for the intercept, x and x^2. I can infer from this that the probability of getting our result by the intertwined structure of the model is very low.


```{r}
save.image("Independence.Rdata")
#load image if desired
load("Independence.Rdata")
```