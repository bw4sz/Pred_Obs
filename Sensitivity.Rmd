---
title: "Sensitivity to Suitability Threshold"
author: "Ben Weinstein"
date: "Monday, November 24, 2014"
output:
  html_document:
    toc: true
---

```{r,warning=FALSE,message=FALSE}
#Load required libraries
library(reshape2)
require(ggplot2)
library(picante)
library(dismo)
library(ape)
library(doSNOW)
library(gdistance)
library(foreach)
library(boot)
library(maptools)
library(rasterVis)
library(knitr)
library(vegan)
library(gridExtra)
library(R2jags)
library(stringr)
library(dplyr)

opts_chunk$set(warning=FALSE,message=FALSE)
opts_chunk$set(cache=TRUE, cache.path = 'Sensitivity_cache/', fig.path='figure/',fig.width=10,echo=FALSE)

#Set git path
gitpath<-"C:/Users/Ben/Documents/Pred_Obs/"
droppath<-"C:/Users/Ben/Dropbox/"

setwd(gitpath)
source(paste(gitpath,"SpeciesOverlapSourceFunctions.R",sep=""))

#Load image if desired
load(paste(droppath,"Thesis/Pred_Realized/Assemblages/Threshold0.2/Results/PredictedRealized.RData",sep=""))

rm(predAssemblages)
rm(pred_realized)

source(paste(gitpath,"SpeciesOverlapSourceFunctions.R",sep=""))

```

Define predicted assemblage function.

```{r,eval=TRUE}
predAssemblages<-function(thresh,plots=TRUE){

  #Create output folders

  fold<-paste(droppath,paste("Thesis/Pred_Realized/Assemblages/Threshold",thresh,sep=""),sep="")

#Read in source function to draw predicted and realized assemblages and match relatedness

dir.create(fold)
dir.create(paste(fold,"Species",sep="/"))

#load models to file, makes it more transferable than keeping them on disk

#Choose the model output, for now i'm getting the mean ensemble model
modlist<-stack(lapply(niche,raster,values=TRUE))

#plot a few rasters
print("Example niche models")
if(plots){plot(modlist[[1:6]])}

#or read from file
#writeRaster(paste(gitpath,"modelStack",sep=""),x=stack(modlist),bylayer=FALSE,overwrite=TRUE)
#modlist<-stack(paste(gitpath,"modelStack",sep=""))

  #Lets go get the presence data on hummingbird distributions
  Niche_locals<-read.csv(paste(gitpath,"InputData\\MASTER_POINTLOCALITYarcmap_review.csv",sep=""))
  
  #Just take the columns you want. 
  PAdat<-Niche_locals[,colnames (Niche_locals) %in% c("RECORD_ID","SPECIES","COUNTRY","LOCALITY","LATDECDEG","LONGDECDEG","Decision","SpatialCheck","MapDecision")]
  
  #clean localities, we checked them against published range records and visually inspected them
  PAdat<-PAdat[!PAdat$LONGDECDEG==-6,]
  loc_clean<-PAdat[PAdat$Decision=="OK"|PAdat$MapDecision=="OK"|PAdat$MapDecision=="",]
  loc_clean<-loc_clean[loc_clean$SpatialCheck=="Y",]
  
  
#########################################################
#Perform Predicted v Realized Function on all Niche Models
#########################################################

cl<-makeCluster(12,"SOCK")
registerDoSNOW(cl)

system.time(all_models<-foreach(x=1:nlayers(modlist),.export=c("sp.lists","siteXspp.raster","pred_realized","fold","gitpath","cellSitesXY","costThresh","CostPathMatrix","loc_clean"),.errorhandling="stop",.packages=c("raster","maptools","reshape2","dismo","picante","ggplot2","rasterVis","lattice")) %dopar%{
  
  source(paste(gitpath,"SpeciesOverlapSourceFunctions.R",sep=""))
  
  pred_realized(mod=modlist[[x]],thresh.suit=thresh,dispersal=FALSE,plots=FALSE,loc_clean=loc_clean)
  
  })

if(plots){print("Species assembages: No dispersal filter")}

#If you want to start here, read in the data from file

#combine all datasets
#This naming function would need to changed on other systems
names(all_models)<-names(modlist)

#Remove models that failed. 
working_models<-all_models[!sapply(sapply(all_models,nrow),is.null)]
failed_models<-all_models[sapply(sapply(all_models,nrow),is.null)]
write.csv(names(failed_models),"FailedSpecies.csv")

#melt and name list
#remove any species that failed. 
all.species.dataND<-melt(working_models,id.vars=c("Locality","P_A","Suitability","Species","LongDecDeg","LatDecDeg"))

##############Repeat for dispersal filter########
system.time(all_modelsDD<-foreach(x=1:nlayers(modlist),.errorhandling="stop",.export=c("sp.lists","siteXspp.raster","pred_realized","fold","gitpath","cellSitesXY","costThresh","CostPathMatrix","loc_clean"),.packages=c("raster","maptools","reshape2","dismo","picante","ggplot2","rasterVis","lattice")) %dopar%{ 
    
  source(paste(gitpath,"SpeciesOverlapSourceFunctions.R",sep=""))
    
  pred_realized(mod=modlist[[x]],thresh.suit=thresh,dispersal=TRUE,plots=FALSE,loc_clean=loc_clean)
})

#turn
stopCluster(cl)

if(plots){print("Species assemblages including dispersal filter")}

#combine all datasets
#This naming function would need to changed on other systems
names(all_modelsDD)<-names(modlist)

#Remove models that failed. 
working_modelsD<-all_modelsDD[!sapply(sapply(all_modelsDD,nrow),is.null)]
failed_modelsD<-all_modelsDD[sapply(sapply(all_modelsDD,nrow),is.null)]
write.csv(names(failed_modelsD),"FailedSpeciesD.csv")

#melt and name list
#remove any species that failed. 
all.species.dataD<-melt(working_modelsD,c("Locality","P_A","Suitability","Species","LongDecDeg","LatDecDeg"))

all.species.dataND$Hyp<-"Env"
all.species.dataD$Hyp<-"Env_Dispersal"

#Merge together as a list, name the hyps and melt
all.species.data<-rbind_all(list(all.species.dataND,all.species.dataD))

#drop duplicate name column
all.species.data<-all.species.data[,!colnames(all.species.data) %in% "L1"]

#Set working directory to output folder
dir.create(paste(fold,"Results",sep="/"))
setwd(paste(fold,"Results",sep="/"))

#Visualize model outputs
ggplot(all.species.data,aes(x=Suitability,fill=P_A)) + geom_density(alpha=.5) + theme_bw() + labs(fill="") + facet_wrap(~Hyp) + ggtitle("Habitat Suitability and Presence")
ggsave("AllspeciesBinarySuitability.svg",height=8,width=10) 

#add in which clade each focal species is
PA_mult2<-merge(all.species.data,clades[,-c(3,4,5)],by.x="Species",by.y="double.")

#remove the "Present/Absent column" it needs to be 0,1
PA_m2<-PA_mult2[,-3]

#Name the columns
colnames(PA_m2)[c(6,7)]<-c("P_R","P_A")

#merge with phylogenetic distance
PA_m2<-merge(PA_m2,PA_phylo[,-3],by=c("Species","Locality"))

#Final data format
PA_m2<-PA_m2[!(PA_m2$Hyp=="Env_Dispersal" & PA_m2$P_R=="PA_Binary"),]

#take out values greater than 95% quartile
phylo_out<-with(PA_m2,quantile(PA_m2[,"Phylo.Relatedness"],.95,na.rm=T))

#remove outliers
PA_m2$Phylo.Relatedness[PA_m2$Phylo.Relatedness > phylo_out]<-NA 

#return data
return(PA_m2)
}

```

#Loop through suitability thresholds

```{r}
#list of thresholds
thr<-seq(.1,.9,.1)
thr_loop<-lapply(thr,function(x){
  predAssemblages(thresh=x,plots=FALSE)})
```

#Plot glm estimates of polynomial

While this is ignoring the between species differences, for the sake of computational efficiency, I will use a frequentist method to test the effect of threshold on polynomial estimates

```{r}
names(thr_loop)<-thr

for(x in 1:length(thr_loop)){
thr_loop[[x]]$Thresh<-thr[x]
  }

PA_m2<-rbind_all(thr_loop)

#legacy name change.
datF<-PA_m2

#make formats the same
datF$Locality<-as.numeric(as.character(datF$Locality))
datF$P_A<-as.integer(datF$P_A)

#split data into types of assemblages
#drop Env + Dispersal for observed, its just a data subset
sdat<-split(datF,list(datF$P_R,datF$Hyp),drop=TRUE)

names(sdat)<-c("Env","Observed","Env + Dispersal")

#remove the observed dat
sdat<-sdat[-2]

#for now grab 10000 random samples and remove inf values
sdat<-lapply(sdat,function(x){
  x<-x[is.finite(x$Phylo.Relatedness),]
  return(x)
})
```

#View plots
```{r}
plotlist<-lapply(sdat,function(x){
p<-ggplot(x,aes(x=Phylo.Relatedness,y=P_A,col=factor(Thresh))) + geom_smooth(method="glm",family="binomial",formula=y~poly(x,2)) + theme_bw() + labs("x=Distance to closest related species in an assemblage",y="Probability of presence") + ggtitle("") + scale_color_brewer(palette="Reds") + labs(col="Habitat Suitability Threshold")
return(p)
})

#title plots
for (x in 1:length(plotlist)){
  plotlist[[x]]<-plotlist[[x]]+ggtitle(names(plotlist)[x])
}

do.call(grid.arrange,plotlist,nrow=2)
```
